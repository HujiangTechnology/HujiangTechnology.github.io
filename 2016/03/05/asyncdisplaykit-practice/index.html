<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深度实践 AsyncDisplayKit | 移动开发</title>
  <meta name="author" content="移动开发">
  
  <meta name="description" content="这里能学到最新最牛的技术，帮你规划大牛之道。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="深度实践 AsyncDisplayKit"/>
  <meta property="og:site_name" content="移动开发"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/https://avatars3.githubusercontent.com/u/13547892?v=3&s=200" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/flatly.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">移动开发</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/tags/iOS技术周刊/" title="技术周刊">
			  <i class="fa fa-apple"></i>周刊
			</a>
		  </li>
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>归档
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>关于
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Feed">
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 深度实践 AsyncDisplayKit</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>追求极致的用户体验，从来都是我们锲而不舍的追求，对于iOS用户而言，这更是容不得一点马虎。随着时间的推移，现如今，谁还能忍受得了一个页面打开后，半天没有结果😭，出来之后滑动卡顿，点击个按钮半天木有反应啊，有木有？还好，还有<code>Facebook</code>，这位互联网IT界的大佬，为我们带来了福音，它就是我们今天要讲的<code>AsyncDisplayKit</code>。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>AsyncDisplayKit</code> 可以给我们带来很棒的用户体验，主要是通过优化以下3点：</p>
<ul>
<li>图像解码</li>
<li>页面布局</li>
<li>页面元素渲染</li>
</ul>
<p>通过把以上几项操作放在后台线程，从而避免了阻塞用户主线程。所以，通过这个库，如果使用得当，即使是复杂的页面布局我们仍可以获得丝滑般的无限接近60FPS的页面滚动体验，这一点，通过常规的<code>UIKit</code>优化一般是达不到这个效果的😏。</p>
<p>在本文中，我们通过一个开始的初级项目（主要是使用了<code>UICollectionView</code>，有一些滚动体验不佳），通过使用<code>AsyncDisplayKit</code>来优化提升它的性能。跟着我走，你将会学会如何在你自己的项目中使用  <code>AsyncDisplayKit</code> 。</p>
<p>&gt;<br>注意: 在开始之前, 你最好对 Swift, Core Animation 和 Core Graphics这些知识已经有所了解.</p>
<h2 id="开始了"><a href="#开始了" class="headerlink" title="开始了"></a>开始了</h2><p>开始之前，如果有时间的话，你最好看一下<a href="https://code.facebook.com/posts/721586784561674/introducing-AsyncDisplayKit-for-smooth-and-responsive-apps-on-ios/" target="_blank" rel="external">AsyncDisplayKit的介绍</a>，这样你会对 <code>AsyncDisplayKit</code>的主要功能有一个初步的认识。项目源码<em>(EMAIL ME:1043370115@QQ.COM)</em>，先跑起来看看（需要Xcode 6.3 和 the iOS 8.3 SDK 以上环境）。为了能比较明显的看到使用这个库的差异，最好在老一点的设备上运行，如果是模拟器，看到的性能提升不明显，你懂的😏。运行起来，看起来是这样的:<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt=""><br>像你现在看到的，这个app的主页面是一个众多动物卡片组成的一个<code>UICollectionView</code>,每一个卡片包含了一张图片，一条文字描述，以及一个由主图片经过模糊处理的背景。<br></p>
<p> 滚动一下这个页面，注意它的帧率，（我使用的是iPad 3，大概只有20FPS），失帧很严重啊，所以你的直观触觉就是界面很不流畅，卡顿实实在在的。好吧，在这篇文章结束的时候，我们的目标就是要把它搞到（或者无限接近）60FPS。<br></p>
<p> &gt;<br> 注意: 这个项目里你看到的所有图片都是放在本地地资源文件里面的，没有一个是从网络下载来的。</p>
<h2 id="测试响应能力"><a href="#测试响应能力" class="headerlink" title="测试响应能力"></a>测试响应能力</h2><p>在使用<code>AsyncDisplayKit</code>优化你的项目之前，先通过<code>Instruments</code>来检测一下你的应用的响应能力，这一点很重要，可以确保你知道优化后<code>AsyncDisplayKit</code>给你带来了什么变化。<br><br>最重要的是，影响性能的因素中，无非就是<code>CPU</code>，<code>GPU</code>这两块，所以优化前，你应该首先弄清楚你的性能瓶颈在哪里，究竟是受制于<code>CPU</code>还是<code>GPU</code>，是哪一个降低了你应用的FPS。搞清楚这个之后，你可以看到<code>AsyncDisplayKit</code>是如何利用它的特性来帮你优化的。<br><br>如果你有时间的话，你可以使用<code>Instruments</code>来监测一下我们一开始提供的那个项目的性能瓶颈，你会发现它是受制于<code>CPU</code>的。</p>
<h2 id="准备切换到AsyncDisplayKit"><a href="#准备切换到AsyncDisplayKit" class="headerlink" title="准备切换到AsyncDisplayKit"></a>准备切换到AsyncDisplayKit</h2><p>在已存在的项目上使用<code>AsyncDisplayKit</code>很简单，就是把<code>view hierarchies</code>或者/和 <code>layer trees</code>替换为<code>display node hierarchies</code>。  <code>Display nodes</code>是<code>AsyncDisplayKit</code>中很重要的一个概念，它是基于views之上并且线程安全的，这意味着我们平常习惯于在主线程中做的那些views有关的部分工作现在可以脱离主线程了，是不是很惊奇？没错，这就是最大的魅力所在，所以你就可以把有限的资源去处理更重要的事情了，比如<code>touch event</code>或者<code>scroll view</code>的滚动。所以接下来第一步，就是去掉<code>view hierarchy</code>。<br></p>
<h3 id="Removing-the-View-Hierarchy"><a href="#Removing-the-View-Hierarchy" class="headerlink" title="Removing the View Hierarchy"></a>Removing the View Hierarchy</h3><p>打开 <code>RainforestCardCell.swift</code>，在 <code>awakeFromNib()</code> 删除所有的 <code>addSubview(...)</code> 调用, 像这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">  contentView.layer.borderColor =</span><br><span class="line">    <span class="type">UIColor</span>(hue: <span class="number">0</span>, saturation: <span class="number">0</span>, brightness: <span class="number">0.85</span>, alpha: <span class="number">0.2</span>).<span class="type">CGColor</span></span><br><span class="line">  contentView.layer.borderWidth = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换<code>layoutSubviews()</code> 为下面的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  		<span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换<code>configureCellDisplayWithCardInfo(cardInfo:)</code> 为下面的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureCellDisplayWithCardInfo</span><span class="params">(cardInfo: RainforestCardInfo)</span></span> &#123;</span><br><span class="line">  <span class="comment">//MARK: Image Size Section</span></span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: cardInfo.imageName)!</span><br><span class="line">  featureImageSizeOptional = image.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除<code>RainforestCardCell</code>中所有的<code>view</code>属性，剩下来的像这样：<br></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RainforestCardCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> featureImageSizeOptional: <span class="type">CGSize</span>?</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后保存并运行，结果像这样：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt=""><br>现在都是一些空的cells,所以你滚动起来相当顺滑，我们的目标就是当这些cell填上内容之后，仍然保持这样的触感。在你每做一步之后，你可以使用<code>Instruments’s Core Animation template</code>来观察app的帧率有什么变化。<br></p>
<h3 id="Adding-a-Placeholder"><a href="#Adding-a-Placeholder" class="headerlink" title="Adding a Placeholder"></a>Adding a Placeholder</h3><p>在<code>RainforestCardCell.swift</code>中添加一个属性<code>placeholderLayer</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RainforestCardCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">var</span> featureImageSizeOptional: <span class="type">CGSize</span>?</span><br><span class="line">  	<span class="keyword">var</span> placeholderLayer: <span class="type">CALayer</span>!</span><br><span class="line">  		...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用placeholder是因为我们的cell的内容展示的时候是异步的，为了不让用户看到空的cell。这就像我们从网络下载图片的时候的做法一样，当图片下载完成之前先设置一个placeholder。</p>
<p>在<code>awakeFromNib()</code>中，配置<code>placeholderLayer</code>，然后该方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">   	<span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">  	placeholderLayer = <span class="type">CALayer</span>()</span><br><span class="line">  	placeholderLayer.contents = 	<span class="type">UIImage</span>(named:<span class="string">"cardPlaceholder"</span>)!.<span class="type">CGImage</span></span><br><span class="line">  	placeholderLayer.contentsGravity = kCAGravityCenter</span><br><span class="line">  	placeholderLayer.contentsScale = <span class="type">UIScreen</span>.mainScreen().scale</span><br><span class="line">   	placeholderLayer.backgroundColor = <span class="type">UIColor</span>(hue: <span class="number">0</span>, saturation: <span class="number">0</span>, 		brightness: <span class="number">0.85</span>, alpha: <span class="number">1</span>).<span class="type">CGColor</span></span><br><span class="line">  	contentView.layer.addSublayer(placeholderLayer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>layoutSubviews()</code>, 加载<code>placeholderLayer</code>,修改后的方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">  	placeholderLayer?.frame = bounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，看起来是这样：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt=""></p>
<p>普通的<code>CALayers</code>单独使用，没有与view关联的时候，当你改变frame的时候它们会有一个隐式的动画，所以你应该会看到当那个layer加载出来的时候有一个缩放的动画，为了修改这个问题，我们重写<code>layoutSubviews</code>方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">  <span class="type">CATransaction</span>.begin()</span><br><span class="line">  <span class="type">CATransaction</span>.setValue(kCFBooleanTrue,</span><br><span class="line">  forKey:kCATransactionDisableActions)</span><br><span class="line">  placeholderLayer?.frame = bounds</span><br><span class="line">  <span class="type">CATransaction</span>.commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译运行，你会发现刚才的问题解决了。</p>
<h2 id="Your-First-Node"><a href="#Your-First-Node" class="headerlink" title="Your First Node"></a>Your First Node</h2><p>我们要重构这个app的第一步就是添加一个node，在这一部分，我们将要处理以下几个任务：<br></p>
<ul>
<li>创建，布局，添加 node 到 cell 中</li>
<li>重用 cell 以及其中的 node 和 layer</li>
<li>对 image node 做 blur 处理 </li>
</ul>
<p>接下来，在 <code>Layers-Bridging-Header.h</code>中导入<code>AsyncDisplayKit</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;</span><br></pre></td></tr></table></figure>
<h3 id="项目结构梳理"><a href="#项目结构梳理" class="headerlink" title="项目结构梳理"></a>项目结构梳理</h3><ul>
<li>View Controller : <code>RainforestViewController</code> 实际上不做什么事情，只是简单的获得数据源并实现<code>UICollectionView</code>的代理。</li>
<li>Data Source : view controller 生成并重用cell，通过调用<code>configureCellDisplayWithCardInfo(cardInfo:)</code>配置cell。</li>
<li>Cell : 在 <code>configureCellDisplayWithCardInfo(cardInfo:)</code>方法中，cell生成node并添加到cell上面，然后布局nodes。</li>
</ul>
<p>这意味着每一次重用cell的时候，都会重复这些动作 。<br>如果你是用views代替nodes，那这样绝对不是最好的做法。但是现在用的是nodes，因为nodes的生成，布局以及填充，这些步骤都是可以放在异步线程做的，所以目前还不是问题，当然我们后续还会优化。唯一的问题是这样做的话，你不能很方便的取消这些异步操作或者是在重用cell的时候删除nodes。</p>
<p>&gt;</p>
<blockquote>
<p>Note : 在实际的开发中，你可以选择使用ASRangeController来缓存nodes，这样你就不需要在每次重用cell的时候去重新生成nodes。</p>
</blockquote>
<h3 id="Adding-the-Background-Image-Node"><a href="#Adding-the-Background-Image-Node" class="headerlink" title="Adding the Background Image Node"></a>Adding the Background Image Node</h3><p>打开 <code>RainforestCardCell.swift</code> 然后替换 <code>configureCellDisplayWithCardInfo(cardInfo:)</code> 为如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureCellDisplayWithCardInfo</span><span class="params">(cardInfo: RainforestCardInfo)</span></span> &#123;</span><br><span class="line">  	<span class="comment">//MARK: Image Size Section</span></span><br><span class="line">  	<span class="keyword">let</span> image = <span class="type">UIImage</span>(named: cardInfo.imageName)!</span><br><span class="line">  	featureImageSizeOptional = image.size</span><br><span class="line">  	<span class="comment">//MARK: Node Creation Section</span></span><br><span class="line">  	<span class="keyword">let</span> backgroundImageNode = <span class="type">ASImageNode</span>()</span><br><span class="line">  	backgroundImageNode.image = image</span><br><span class="line">  	backgroundImageNode.contentMode = .<span class="type">ScaleAspectFill</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>ASImageNode</code>是<code>AsyncDisplayKit</code>中用来做展示用的众多nodes中的一种，等价于<code>UIKit</code>中的<code>UIImageView</code>，只是<code>ASImageNode</code>默认情况下的图片解码操作是异步的。</p>
<p>在<code>configureCellDisplayWithCardInfo(cardInfo:)</code>的末尾添加下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backgroundImageNode.layerBacked = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Nodes有两种模式，一般情况下当需要处理某些事件的时候比如<code>touch event</code>，我们采用<code>view-backed</code>模式，反之如果只是纯粹的展示则采用<code>layer-backed</code>模式，<code>layer-backed</code>模式相对而言是轻量级的，会有更好一点的性能。由于我们这个项目中不需要处理事件，所以<code>backgroundImageNode</code>采用<code>layer-backed</code>模式。</p>
<p>在<code>configureCellDisplayWithCardInfo(cardInfo:)</code>的末尾继续添加下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: Node Layout Section</span></span><br><span class="line">backgroundImageNode.frame = <span class="type">FrameCalculator</span>.frameForContainer(featureImageSize: image.size)</span><br></pre></td></tr></table></figure>
<p><code>FrameCalculator</code>是个辅助类，封装了cell的布局处理，返回每一个node的frame。如果你要适配多个设备尺寸，这里你要谨慎处理，你可以看到这里没有使用约束，因为<code>AsyncDisplayKit</code>目前版本并不支持约束，希望后续支持吧。</p>
<p>在<code>configureCellDisplayWithCardInfo(cardInfo:)</code>的末尾继续添加下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: Node Layer and Wrap Up Section</span></span><br><span class="line"><span class="keyword">self</span>.contentView.layer.addSublayer(backgroundImageNode.layer)</span><br></pre></td></tr></table></figure>
<p>上面已经提到了，<code>AsyncDisplayKit</code>会为<code>backgroundImageNode</code>创建一个layer，但是你仍然需要把这个node添加到<code>layer tree</code>中，它才可以在屏幕上显示。另外由于node的绘制是异步的，所以在绘制完成之前它是不会显示的，尽管你已经把它添加到<code>layer tree</code>中了，这一点需要注意。当node的图片绘制完成之后，node的layer的content就会被更新，这个时候cell的 <code>content view</code>的layer会有两个sublayer.</p>
<p>你应该会注意到cell每次被取出重用的时候，<code>configureCellDisplayWithCardInfo(cardInfo:)</code>都会被调用，所以每次该方法调用的时候，我们都会添加一个新的layer到cell的contentview的layer上面，不过别担心，我们马上就会解决这个问题。</p>
<p>在<code>RainforestCardCell.swift</code>中新添加一个变量<code>backgroundImageNode</code>像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RainforestCardCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> featureImageSizeOptional: <span class="type">CGSize</span>?</span><br><span class="line">  <span class="keyword">var</span> placeholderLayer: <span class="type">CALayer</span>!</span><br><span class="line">  <span class="keyword">var</span> backgroundImageNode: <span class="type">ASImageNode</span>? <span class="comment">///&lt; ADD THIS LINE</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加这个属性我们可以持有这个node，是因为在<code>ARC</code>环境下，某些时候它会被释放，这样就不会显示在屏幕上了。node是持有它的layer的引用的，但是它的layer并不持有node，所以我们需要持有这个node。</p>
<p>在<code>configureCellDisplayWithCardInfo(cardInfo:)</code>的末尾继续添加下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.backgroundImageNode = backgroundImageNode</span><br></pre></td></tr></table></figure>
<p>好了，目前为止，<code>configureCellDisplayWithCardInfo(cardInfo:)</code>是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureCellDisplayWithCardInfo</span><span class="params">(cardInfo: RainforestCardInfo)</span></span> &#123;</span><br><span class="line">  <span class="comment">//MARK: Image Size Section</span></span><br><span class="line">  <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: cardInfo.imageName)!</span><br><span class="line">  featureImageSizeOptional = image.size</span><br><span class="line">  <span class="comment">//MARK: Node Creation Section</span></span><br><span class="line">  <span class="keyword">let</span> backgroundImageNode = <span class="type">ASImageNode</span>()</span><br><span class="line">  backgroundImageNode.image = image</span><br><span class="line">  backgroundImageNode.contentMode = .<span class="type">ScaleAspectFill</span></span><br><span class="line">  backgroundImageNode.layerBacked = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//MARK: Node Layout Section</span></span><br><span class="line">  backgroundImageNode.frame = <span class="type">FrameCalculator</span>.frameForContainer(featureImageSize: image.size)</span><br><span class="line">  <span class="comment">//MARK: Node Layer and Wrap Up Section</span></span><br><span class="line">  <span class="keyword">self</span>.contentView.layer.addSublayer(backgroundImageNode.layer)</span><br><span class="line">  <span class="keyword">self</span>.backgroundImageNode = backgroundImageNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，你可以观察到<code>backgroundImageNode</code>的图片的异步呈现，感觉一下效果吧。<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt=""></p>
<p>如果你运行在一个老一点的设备上，你会发现那些cell上的图片像爆米花一样一个个跳出来了，这并不是我们的理想结果，这个问题我们会放在最后解决。</p>
<p>正如上面我已经提到的，每次cell重用的时候，都会有一个新的layer被加上去，你可以快速滚动页面，然后打个断点在cell里面，会发现很有多layer在上面，接下来我们就来处理这个问题。</p>
<h3 id="Handling-Cell-Reuse"><a href="#Handling-Cell-Reuse" class="headerlink" title="Handling Cell Reuse"></a>Handling Cell Reuse</h3><p>首先继续在<code>RainforestCardCell.swift</code>, 添加个<code>contentLayer</code>，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RainforestCardCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">var</span> featureImageSizeOptional: <span class="type">CGSize</span>?</span><br><span class="line">  		<span class="keyword">var</span> placeholderLayer: <span class="type">CALayer</span>!</span><br><span class="line">  		<span class="keyword">var</span> backgroundImageNode: <span class="type">ASImageNode</span>?</span><br><span class="line">  		<span class="keyword">var</span> contentLayer: <span class="type">CALayer</span>? <span class="comment">///&lt; ADD THIS LINE</span></span><br><span class="line">  		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>configureCellDisplayWithCardInfo(cardInfo:)</code>的末尾继续添加下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.contentLayer = backgroundImageNode.layer</span><br></pre></td></tr></table></figure>
<p>然后替换 <code>prepareForReuse()</code>方法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="keyword">super</span>.prepareForReuse()</span><br><span class="line">  	backgroundImageNode?.preventOrCancelDisplay = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>AsyncDisplayKit</code>可以异步绘制，nodes可以让你阻止任何正在进行的绘制，当你需要取消或者停止绘制的时候只需要设置它的<code>preventOrCancelDisplay</code>为<code>true</code>即可，这样你就可以在cell重用之前停止之前的所有绘制，是不是很赞？</p>
<p>接下来，在<code>prepareForReuse()</code>中再添加几行代码，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contentLayer?.removeFromSuperlayer()</span><br><span class="line">contentLayer = <span class="literal">nil</span></span><br><span class="line">backgroundImageNode = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>这几行代码简单易懂，就是在cell重用之前，把相应的layer和node都删除，并确保被释放掉，这样就解决了上面提到的layer堆积的问题。<br>编译运行，这一次就不会有layer堆积了，并且在cell滚出屏幕可视范围后，取消不必要的绘制。</p>
<h3 id="Blurring-the-Image"><a href="#Blurring-the-Image" class="headerlink" title="Blurring the Image"></a>Blurring the Image</h3><p>为了添加blur效果，需要我们在imagenode的展示过程中加入一些步骤。在<code>RainforestCardCell.swift</code>文件的<code>configureCellDisplayWithCardInfo(cardInfo:)</code>方法中做点修改，在<code>backgroundImageNode.layerBacked = true</code>后面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">backgroundImageNode.imageModificationBlock = &#123; input <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">if</span> input == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> blurredImage = input.applyBlurWithRadius(</span><br><span class="line">    <span class="number">30</span>,</span><br><span class="line">    tintColor: <span class="type">UIColor</span>(white: <span class="number">0.5</span>, alpha: <span class="number">0.3</span>),</span><br><span class="line">    saturationDeltaFactor: <span class="number">1.8</span>,</span><br><span class="line">    maskImage: <span class="literal">nil</span>, </span><br><span class="line">    didCancel:&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;) &#123;</span><br><span class="line">      <span class="keyword">return</span> blurredImage</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ASImageNode</code>的<code>imageModificationBlock</code>给了我们一个机会在展示原始图片之前可以做一些其他的操作，比如滤镜操作，模糊处理等。</p>
<p>上面的代码，使用<code>imageModificationBlock</code>，给cell的背景图加上了模糊效果。最关键的一点是imagenode把绘制动作和这个闭包操作放在了子线程，这样就使主线程运行顺畅，这个闭包把原始图片作为参数然后返回处理后的图片。</p>
<p>这个模糊处理是使用了系统的方法，<code>UIImage</code> 的 <code>blurring category</code>，它主要是使用<code>Accelerate framework</code> 基于<code>CPU</code>来做的模糊操作。由于这个模糊处理会消耗内存同时也比较耗时，所以就支持了取消机制，<code>didCancel</code>闭包会被多次调用来监测是否应该取消模糊操作。目前为止，上面的代码只是简单返回了<code>false</code>，稍后我们就会来实际修改<code>didCancel</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Note</span> : 还记得一开始的时候你滑动页面的时候是什么感觉么？那个模糊处理严重的阻塞了主线程，通过<span class="type">AsyncDisplayKit</span>把这个操作放入子线程，现在大大提升了collection view滚动时候的体验。这简直就是一个天上，一个地下啊，有木有？</span><br></pre></td></tr></table></figure>
<p>运行看看现在的效果吧：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt=""></p>
<p>现在你可以看到<code>collection view</code>滚动起来是有多么的顺滑。</p>
<p>当<code>collection view</code>从重用队列取出一个cell重用的时候就开始了一个模糊处理操作，所以当你快速滚动的时候，<code>collection view</code>就会重用每一个cell很多次，理所当然的就启动了很多模糊处理的操作。这个当然不合理了😏😏，所以我们的目标应该是当一个cell开始重用的时候，去取消之前的模糊处理操作。</p>
<p>在前面我们已经可以在<code>prepareForReuse()</code>中取消node的绘制，所以一旦我们有机会在合适的时候取消模糊操作的话，那就毫不犹豫的去取消吧。</p>
<h3 id="Canceling-the-Blur"><a href="#Canceling-the-Blur" class="headerlink" title="Canceling the Blur"></a>Canceling the Blur</h3><p>为了取消那些正在进行的blur操作，我们需要重新实现blur方法中的<code>didCancel</code>闭包。添加如下代码到<code>imageModificationBlock</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">backgroundImageNode.imageModificationBlock = &#123; [<span class="keyword">weak</span> backgroundImageNode] input <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">if</span> input == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ADD FROM HERE...</span></span><br><span class="line">  <span class="keyword">let</span> didCancelBlur: () -&gt; <span class="type">Bool</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> isCancelled = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> strongBackgroundImageNode = backgroundImageNode &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">let</span> isCancelledClosure = &#123;</span><br><span class="line">        isCancelled = strongBackgroundImageNode.preventOrCancelDisplay</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">if</span> <span class="type">NSThread</span>.isMainThread() &#123;</span><br><span class="line">        isCancelledClosure()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isCancelled</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...TO HERE</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，我们这里需要使用一个<code>weak reference</code>来避免<code>closure</code>和<code>backgroundImageNode</code>的循环引用。我们就使用<code>backgroundImageNode</code>来决定是否需要取消模糊处理。</p>
<p>上面的代码完成了如下几个功能：</p>
<ul>
<li>首先获得<code>backgroundImageNode</code>的一个强引用，为我们接下来的操作做准备。如果当这个闭包运行的时候<code>backgroundImageNode</code>不存在了，那么<code>isCancelled</code>就会为<code>true</code>，blur操作就会被取消，那我们就别提做什么blur操作了。</li>
<li>你会有疑问，在这个地方为什么取消blur的这个闭包中的代码会要求放在主线程来操作，这是因为一旦node创建了它的<code>layer</code>或者<code>view</code>之后，你就只能在主线程来访问node的属性了（这一点很重要）。由于我们需要使用node的<code>preventOrCancelDisplay</code>这个属性，而此时<code>backgroundImageNode</code>的layer已经创建过了，所以我们必须把这个监测放在主线程中。</li>
<li>由于我们需要确保<code>isCancelledClosure</code>会在主线程来被调用，所以如果是在主线程就直接访问<code>preventOrCancelDisplay</code>，否则的话就使用<code>dispatch_sync</code>来在主线程访问。你又有疑问么😏，这里又为什么使用<code>dispatch_sync</code>来同步执行，是因为我们必须在<code>didCancelBlur</code>闭包返回之前给一个明确的结果，即返回一个确切的<code>isCancelled</code>值。</li>
</ul>
<p>最后，在调用<code>applyBlurWithRadius(...)</code>方法的地方，把刚才我们定义好的闭包作为值传给<code>didCancel</code>这个参数，所以代码看起来像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> blurredImage = input.applyBlurWithRadius(</span><br><span class="line">  <span class="number">30</span>,</span><br><span class="line">  tintColor: <span class="type">UIColor</span>(white: <span class="number">0.5</span>, alpha: <span class="number">0.3</span>),</span><br><span class="line">  saturationDeltaFactor: <span class="number">1.8</span>,</span><br><span class="line">  maskImage: <span class="literal">nil</span>,</span><br><span class="line">  didCancel: didCancelBlur) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，你会发现有很大不同，现在当cell滚出屏幕后，它相应的blur操作也会被取消，这样我们会节省很多内存开销，同时减少了不必要的CPU时间片占用。你将会看到巨大的性能提升，尤其是在配置低一点的设备上。</p>
<p>当然了，也不可能把所有的操作都搬到子线程，我们的卡片还需要其他的数据展示，在接下来的文章中，我们还将学习以下几点：</p>
<ul>
<li>创建一个node容器来绘制其他内容并添加到一个单一的<code>CALayer</code>上面；</li>
<li>自定义<code>ASDisplayNode</code>；</li>
<li>在子线程来创建node层级并布局sub nodes</li>
</ul>
<p>所以接下来，敬请期待吧😊😊😊</p>
	  
	</div>


    <!-- share -->
    
        

        
    <!-- JiaThis Button BEGIN -->
    <div class="jiathis_style_24x24">
        <a class="jiathis_button_weixin"></a>
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_twitter"></a>
        <a class="jiathis_button_fb"></a>
        <a class="jiathis_button_googleplus"></a>
        <a class="jiathis_button_linkedin"></a>
        <a class="jiathis_button_copy"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
    </div>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
    <!-- JiaThis Button END -->
    <br>


    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">评论</h2>

  
  	 <div class="ds-thread" data-thread-key="2016/03/05/asyncdisplaykit-practice/" data-title="深度实践 AsyncDisplayKit" data-url="http://yoursite.com/2016/03/05/asyncdisplaykit-practice/"></div>  
  
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2016-03-05 
	</div>
	

	<!-- author -->
	
	<div class="meta-widget">
	<i class="fa fa-user"></i>
	元相 
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->

<script type="text/javascript">
  var duoshuoQuery = { short_name: 'hujiangios' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



	</div>
  </div>
  <div class="container-narrow">
  <footer> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
      
<p>
<p>
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
    本文总阅读量<span id="busuanzi_value_page_pv"></span>次 
</p>
<br>

  &copy; 2016 移动开发
     
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
